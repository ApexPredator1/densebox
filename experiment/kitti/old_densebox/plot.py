import sys,os,copy,random
import argparse
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
class Iteration:
    def __init__(self, iteration_id):
        self.id = iteration_id
        self.data = dict()
    def add(self, k, v):
        self.data[k] = v
    def clone(self):
        i = Iteration(self.id)
        for k,v in self.data.iteritems():
            i.add(k, v)
        return i
    def pp(self):
        print self.id, self.data

def get_value(line, key):
    value = line.split(key)[1].split()[0]
    if value[-1] == ",": # trick for Iteration 1000,
        value = value[:-1]
    return value

def kill_outlier(iters, values):
    assert(len(iters) == len(values))
    ave = 0.0
    for value in values:
        ave += value
    ave /= len(values)
    kill = list()
    for i in xrange(len(values)):
        if values[i] > 4 * ave:
            kill.append(i)
    iters = [iters[i] for i in xrange(len(iters)) if not i in kill]
    values = [values[i] for i in xrange(len(values)) if not i in kill]
    assert(len(iters) == len(values))
    return (iters, values)

def range_average(iters, values, split=200):
    assert(len(iters) == len(values))
    split = min(split, len(iters))
    num_inst = len(iters) / split
    assert(num_inst >= 1)
    new_iters = list()
    new_values = list()
    for i in xrange(0, len(iters), num_inst):
        ave = 0.
        num_inst_iter = min(len(iters), i + num_inst) - i  
        for j in xrange(i, i + num_inst_iter):
            ave += values[j]
        ave /= num_inst_iter
        new_iters.append(iters[i])
        new_values.append(ave)
    assert(len(new_iters) == len(new_values))
    return (new_iters, new_values)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-nice", help="kill outlier", action='store_true', default=False)
    parser.add_argument("-slim", help="range average", action='store_true', default=False)
    parser.add_argument('log', help="log file generated by Caffe")
    parser.add_argument('-save', help="save image to path", default=None)
    parser.add_argument('-ylim_max', help="max limitation of y-axis", default=-1, type=int)
    parser.add_argument('-only_test', help='only show test related', action='store_true', default=False)
    parser.add_argument('-only_train', help='only show train related', action='store_true', default=False)
    args = parser.parse_args()
    
    map = {"iteration_id":"] Iteration ",
            "train-bbox-loss-scale-1":"Train net output #0: bbox-loss-scale-1 = ",
            "train-bbox-loss-scale-2":"Train net output #1: bbox-loss-scale-2 = ",
            "train-bbox-loss-scale-3":"Train net output #2: bbox-loss-scale-3 = ",
            "train-score-loss-scale-1":"Train net output #3: score-loss-scale-1 = ",
            "train-score-loss-scale-2":"Train net output #4: score-loss-scale-2 = ",
            "train-score-loss-scale-3":"Train net output #5: score-loss-scale-3 = ",
            "test-bbox-loss-scale-1":"Test net output #0: bbox-loss-scale-1 = ",
            "test-bbox-loss-scale-2":"Test net output #1: bbox-loss-scale-2 = ",
            "test-bbox-loss-scale-3":"Test net output #2: bbox-loss-scale-3 = ",
            "test-score-loss-scale-1":"Test net output #3: score-loss-scale-1 = ",
            "test-score-loss-scale-2":"Test net output #4: score-loss-scale-2 = ",
            "test-score-loss-scale-3":"Test net output #5: score-loss-scale-3 = "}

    log_file = args.log
    with open(log_file, "r") as f:
        lines = f.readlines()
    current_id = -1
    current_iteration = Iteration(-1)
    iterations = dict()
    for i in xrange(len(lines)):
        line = lines[i].strip()
        for k,v in map.iteritems():
            if v in line:
                if k == "iteration_id":
                    iteration_id = int(get_value(line, v))
                    if current_id == -1:
                        current_id = iteration_id
                        current_iteration.id = current_id
                    elif iteration_id != current_id:
                        # replace same key
                        iterations[current_id] = current_iteration.clone()
                        current_iteration = Iteration(iteration_id)
                        current_id = iteration_id
                else:
                    value = float(get_value(line, v))
                    current_iteration.add(k, value)
    #print iterations
    iterations = sorted(iterations.items(), key=lambda d: d[0], reverse = False)
    #for i in xrange(len(iterations)):
    #    iterations[i].pp()
    fig = plt.figure(figsize=(15, 10))
    fig.suptitle(os.path.basename(log_file), fontsize=13)
    plt.subplot(1, 1, 1)
    plt.grid(True)
    if args.ylim_max != -1:
        axes = plt.gca()
        axes.set_ylim([0, args.ylim_max])
    for k in map.keys():
        if not k.startswith('train') and not k.startswith('test'):
            continue
        if args.only_train and k.startswith("test"):
            continue
        if args.only_test and k.startswith("train"):
            continue
        iters = list()
        values = list()
        for kk,vv in iterations:
            if k in vv.data.keys():
                iters.append(vv.id)
                assert(vv.id == kk)
                values.append(vv.data[k])
        assert(len(iters) == len(values))
        if len(iters) == 0 or len(values) == 0:
            continue
        if args.nice:
            (iters, values) = kill_outlier(iters, values)
        if args.slim:
            (iters, values) = range_average(iters, values)
        if len(iters) > 0 and len(values) > 0:
            color = [random.random(), random.random(), random.random()]
            linewidth = 1.5
            plt.plot(iters, values, '-', linewidth=linewidth, color=color, label=k)
    plt.xlabel('iteration')
    plt.ylabel('value')
    plt.legend()
    if args.save is None:
        save_img_path = args.log + ".png"
    else:
        save_img_path = args.save
    plt.savefig(save_img_path)
